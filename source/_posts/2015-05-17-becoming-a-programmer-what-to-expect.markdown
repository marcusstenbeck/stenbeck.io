---
layout: post
title: "Becoming a Programmer: What to Expect"
date: 2015-05-17 13:12:08 -0700
comments: true
categories: 
---

*To anyone who is considering or has chosen to embark upon the great journey of becoming a programmer.*

As a twenty year-old, I got my first job in technology. Suddenly, instead of selling t-shirts at a mall clothing store, I was paid to design web sites and code them up in HTML and CSS. I got this job because I had been curious enough to figure out how to build my band's web site with PHP and MySQL. The reason I began learning how to program was out of pure utility—we needed an online place to put show dates, photos, and a digital guest book.

<!-- more -->

![The sun rising above the Atlantic. From one of the many trips becoming a programmer has taken me on.](/images/posts/becoming-a-programmer/airplane-window-sunrise.jpg "The sun rising above the Atlantic. From one of the many trips becoming a programmer has taken me on.")

Roughly ten years later and with many years invested in studying and practicing programming, I'm now a creative developer by profession, and I often get to work on projects I truly enjoy. Recently, I've been reflecting upon the winding journey my initial curiosity of programming has taken me on.

I love it because it equips me to explore and build the things that show up in my mind. Naturally, I also sometimes I hate it. Building card houses or Rube Goldberg machines come to mind when thinking of activities similarly as simultaneously rewarding and punishing as coding.

The twenty year-old me saw programming in a much different light than I do now, and if I met him today I would buy him a cup of tea, and let him know what he's in for.

The rabbit hole goes deep.


## Stage 1: "I'm a programmer!"

The first steps into programming are all about exploring and discovering what being able to program affords you to do. This is where the "Hello World" programs are written. They're crude, they don't do anything particularly fantabulous, but they prove that you can make a computer do something.

These are the first few steps into learning the building blocks that make up most programming out there. 

**In this stage:**

 * You'll will likely feel like JavaScript and Ruby, or even C++, are different beasts. Different programming languages look different, and it's easy to think that they are different because of that. Sooner or later you will be able to start seeing what's the same, and what's different—what you want the program to do *(the logic)* is separate from what you write *(the syntax)* to make it happen.
 * You'll realize that doing seemingly simple things, like playing a video, or creating a 3D cube, are surprisingly complicated to do.
 * When you consult more experienced programmers you'll understand that their answers are probably related to what you asked about, but your eyes will glaze over and you'll feel like you've suddenly transformed into Bambi on thin ice.
 * After doing increasingly ambitious projects, a question will start bugging you—"How the hell could one possibly create a *real* program, like, the size of Photoshop?"
 * You'll start to realize that there's so much to learn.


## Stage 2:  "Everybody calm down. I know Computer Science™."

Graduating from the first stage comes with many shifts in thinking about how you should construct your programs. Everything from Big-O and unit testing to the Gang of Four and graph algorithms are introduced. Most of the knowledge gained will be from studying computer science classes in college. 

This stage could potentially set the stage for some painful future experiences, as it will set expectations of how one should write code the "proper way". You'll speak with peers who recount their experiences of going out into "the real world", and not being able, or allowed to practice by the book for various reasons, most of which likely relate to budget and time.

**In this stage:**

 * You'll become aware that there are people who have solved the same problems as you're trying to solve, and they've done it many, many times over again. You'll learn about design patterns, algorithms, and other computer science topics.
 * You'll start learning about the elusive goal of writing "Good Code". You'll also be somewhat convinced that there's a right and a wrong way of writing a program.
 * You'll learn about software testing, and begin getting a hunch of how larger software is possible.
 * You'll learn about version control. In other words, how people work on code together in a group.
 * You *will* apply the theories and concepts you've learned in awkward ways. A hammer sees mostly nails. And you just got a hammer.


## Stage 3: "Let's just make it work, ok?"

After a while, you'll start recognizing when a little dash of hacking might better inform you of how to solve problems "the proper way". You've probably been employed as a programmer for a while now, and have what people refer to as mid-level experience.

**In this stage:**

 * You'll have gained some intuition that while the theory you learned about in school is good and all, the real meat of your challenges lie in understanding when to apply some method, or more importanly when not to.
 * You'll start valuing *YOLO-coding*. This is the process of just making something work *before* going back and looking at how the solution can be improved.
 * You'll start gaining intuition for when it's a good idea to "act" like you're in the first or second stage. You'll have enough skill to mostly avoid terrible mistakes, and you'll have enough experience to realize when you're starting to spend a little *too much* time hypothesizing or optimizing your solutions.


## Stage 4: … I don't know?

This to me is still unknown territory. If I had to make a guess, I think it's further developing the intuition of which solutions to use when faced with particular challenges. I also hope this stage will involve me in helping more aspiring programmers overcome the hurdles in their respective journeys.




*This is obviously my own interpretation of the journey. I'm curious to hear what points people agree or disagree with, or what might be added to the list. For that purpose I've submitted this piece to be discussed at Hacker News ([link to HN](https://news.ycombinator.com/item?id=9561815)).*